/**
 * Plugin Loader Generator
 * Generates auto-loaded loader.js for Next.js static imports
 *
 * This solves the dynamic import problem with Next.js-specific modules
 * by generating a loader that statically imports plugins at build time.
 */

const fs = require('fs').promises;
const path = require('path');

class LoaderGenerator {
  constructor() {
    this.rootDir = path.join(__dirname, '../../../../');
    this.nextjsAppDir = path.join(this.rootDir, 'nextjs-app');
    this.loaderDir = path.join(this.nextjsAppDir, 'plugins-loader');
    this.loaderPath = path.join(this.loaderDir, 'loader.js');
    this.pluginsDir = path.join(this.nextjsAppDir, 'plugins');
  }

  /**
   * Generate the loader.js file based on registered components
   * @param {Map} registeredComponents - Map of component name -> component info
   */
  async generateLoader(registeredComponents) {
    try {
      // Ensure loader directory exists
      await fs.mkdir(this.loaderDir, { recursive: true });

      const imports = [];
      const exportMap = {};
      let importCounter = 0;

      // Build imports and export map
      for (const [componentName, info] of registeredComponents.entries()) {
        const { pluginName, componentPath, metadata } = info;

        // Only generate imports for components with nextjs paths
        if (!componentPath.startsWith('nextjs/')) {
          continue; // Skip bundled dist files
        }

        // Strip 'nextjs/' prefix for import path
        const relativePathFromNextjs = componentPath.replace(/^nextjs\//, '');

        // Remove .js extension if present
        const cleanPath = relativePathFromNextjs.replace(/\.js$/, '');

        // Create import path relative to plugins directory
        const importPath = `../plugins/${pluginName}/${cleanPath}`;

        // Generate unique import identifier
        const importId = `Plugin_${importCounter++}`;

        imports.push({
          id: importId,
          path: importPath,
          componentName,
          pluginName,
          metadata
        });

        // Map component name to import identifier
        exportMap[componentName] = {
          component: importId,
          metadata,
          pluginName
        };
      }

      // Generate loader file content
      const loaderContent = this.generateLoaderContent(imports, exportMap);

      // Write loader file
      await fs.writeFile(this.loaderPath, loaderContent, 'utf8');

      console.log(`  âœ“ Generated loader at ${this.loaderPath} with ${imports.length} component(s)`);

      return {
        success: true,
        loaderPath: this.loaderPath,
        componentCount: imports.length
      };

    } catch (error) {
      console.error('  âœ— Failed to generate loader:', error.message);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Generate the loader file content
   */
  generateLoaderContent(imports, exportMap) {
    const lines = [];

    // File header
    lines.push('/**');
    lines.push(' * AUTO-GENERATED PLUGIN LOADER');
    lines.push(' * DO NOT EDIT THIS FILE MANUALLY');
    lines.push(' * ');
    lines.push(' * Generated by: components/plugins/app/core/loaderGenerator.js');
    lines.push(` * Generated at: ${new Date().toISOString()}`);
    lines.push(' * ');
    lines.push(' * This file statically imports plugin components so Next.js can');
    lines.push(' * resolve all dependencies (including next/navigation) at build time.');
    lines.push(' */');
    lines.push('');

    // Generate imports
    if (imports.length > 0) {
      for (const imp of imports) {
        lines.push(`import ${imp.id} from "${imp.path}";`);
      }
      lines.push('');
    } else {
      lines.push('// No plugin components registered');
      lines.push('');
    }

    // Generate component registry
    lines.push('/**');
    lines.push(' * Plugin component registry');
    lines.push(' * Maps component names to imported components with metadata');
    lines.push(' */');
    lines.push('export const pluginComponents = {');

    if (Object.keys(exportMap).length > 0) {
      const entries = Object.entries(exportMap);
      entries.forEach(([name, info], index) => {
        const isLast = index === entries.length - 1;
        lines.push(`  "${name}": {`);
        lines.push(`    component: ${info.component},`);
        lines.push(`    pluginName: "${info.pluginName}",`);
        lines.push(`    metadata: ${JSON.stringify(info.metadata, null, 6).split('\n').map((line, i) => i === 0 ? line : '    ' + line).join('\n')}`);
        lines.push(`  }${isLast ? '' : ','}`);
      });
    }

    lines.push('};');
    lines.push('');

    // Generate helper functions
    lines.push('/**');
    lines.push(' * Get a plugin component by name');
    lines.push(' * @param {string} name - Component name');
    lines.push(' * @returns {Object|null} Component info or null if not found');
    lines.push(' */');
    lines.push('export function getPluginComponent(name) {');
    lines.push('  return pluginComponents[name] || null;');
    lines.push('}');
    lines.push('');

    lines.push('/**');
    lines.push(' * Get all plugin components for a specific usage type');
    lines.push(' * @param {string} usage - Usage type (e.g., "sidebar-left")');
    lines.push(' * @returns {Array} Array of component info objects');
    lines.push(' */');
    lines.push('export function getComponentsByUsage(usage) {');
    lines.push('  return Object.entries(pluginComponents)');
    lines.push('    .filter(([_, info]) => info.metadata?.usage === usage)');
    lines.push('    .map(([name, info]) => ({ name, ...info }));');
    lines.push('}');
    lines.push('');

    lines.push('/**');
    lines.push(' * Get all registered component names');
    lines.push(' * @returns {Array<string>} Array of component names');
    lines.push(' */');
    lines.push('export function getComponentNames() {');
    lines.push('  return Object.keys(pluginComponents);');
    lines.push('}');
    lines.push('');

    return lines.join('\n');
  }

  /**
   * Create symlink for a plugin's nextjs folder
   * @param {string} pluginName - Name of plugin (e.g., 'rag-plugin')
   */
  async createPluginSymlink(pluginName) {
    try {
      const sourcePath = path.join(this.rootDir, 'bb-plugins', pluginName, 'nextjs');
      const targetPath = path.join(this.pluginsDir, pluginName);

      // Check if source exists
      try {
        await fs.access(sourcePath);
      } catch (err) {
        console.log(`  â„¹ No nextjs/ folder found for ${pluginName}, skipping symlink`);
        return { success: true, skipped: true };
      }

      // Ensure plugins directory exists
      await fs.mkdir(this.pluginsDir, { recursive: true });

      // Remove existing symlink or directory if present
      try {
        await fs.unlink(targetPath);
        console.log(`  âœ“ Removed old symlink: ${targetPath}`);
      } catch (err) {
        // File doesn't exist, that's fine
      }

      // Create symlink (relative path for portability)
      const relativePath = path.relative(this.pluginsDir, sourcePath);
      await fs.symlink(relativePath, targetPath, 'dir');

      console.log(`  âœ“ Created symlink: plugins/${pluginName} -> ${relativePath}`);

      return {
        success: true,
        symlink: targetPath,
        source: sourcePath
      };

    } catch (error) {
      console.error(`  âœ— Failed to create symlink for ${pluginName}:`, error.message);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Remove symlink for a plugin
   * @param {string} pluginName - Name of plugin (e.g., 'rag-plugin')
   */
  async removePluginSymlink(pluginName) {
    try {
      const targetPath = path.join(this.pluginsDir, pluginName);

      // Remove symlink
      try {
        await fs.unlink(targetPath);
        console.log(`  âœ“ Removed symlink: plugins/${pluginName}`);
      } catch (err) {
        if (err.code === 'ENOENT') {
          console.log(`  â„¹ No symlink found for ${pluginName}`);
        } else {
          throw err;
        }
      }

      return { success: true };

    } catch (error) {
      console.error(`  âœ— Failed to remove symlink for ${pluginName}:`, error.message);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Regenerate all symlinks based on active plugins
   * @param {Array} activePlugins - Array of active plugin names
   */
  async regenerateAllSymlinks(activePlugins) {
    console.log(`  ðŸ”— Regenerating symlinks for ${activePlugins.length} active plugin(s)...`);

    const results = [];
    for (const pluginName of activePlugins) {
      const result = await this.createPluginSymlink(pluginName);
      results.push({ pluginName, ...result });
    }

    const successful = results.filter(r => r.success && !r.skipped).length;
    const skipped = results.filter(r => r.skipped).length;
    const failed = results.filter(r => !r.success).length;

    console.log(`  âœ“ Symlinks: ${successful} created, ${skipped} skipped, ${failed} failed`);

    return {
      success: failed === 0,
      results
    };
  }
}

// Export singleton instance
module.exports = new LoaderGenerator();
